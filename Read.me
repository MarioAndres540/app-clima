secuencia de comandos para hacer git push

1) git add .
2) git commit -m "mensaje"
3) git push
4) git reset --hard el limpia culito

--------------------------------------------------------------------------------------------------------------------------------------------------

Qué es Sass 

Sass es un procesador CSS. 

Un preprocesador CSS es una herramienta que nos permite generar, de manera automática,  

hojas de estilo, añadiéndoles características que no tiene CSS, y que son propias de los lenguajes de programación, como pueden ser variables,  

funciones, selectores anidados, herencia, etcétera. 


Estas características de los procesadores nos permiten, además, que el CSS que se genera sea más fácil de mantener y más reutilizable. 

  
Ventajas de utilizar Sass 

El uso de una herramienta como Sass proporciona una serie de ventajas, como son las siguientes: 

Reduce el tiempo para crear y mantener el CSS. 


Permite tener una organización modular de los estilos, lo cual es vital para proyectos grandes. 

  
Proporciona estructuras avanzadas propias de los lenguajes de programación, como variables, listas, funciones y estructuras de control. 

  
Permite generar distintos tipos de salida, comprimida, normal o minimizada, 
trabajando tanto en desarrollo como en producción, además se hace una forma muy fácil. 

  
Permite vigilar los ficheros, de tal manera que, si ha habido un cambio en la hoja de estilos, se regenera automáticamente (modo watch). 

  
Tiene muy pocas dependencias, sobre todo la nueva versión, que es dart-sass.  

En las anteriores versiones se dependía de muchas librerías de Ruby y era un poco engorroso de instalar,  

pero con la nueva versión, la instalación es muy fácil. 

  
Existen muchas herramientas asociadas, muchas librerías hechas con Sass y una comunidad muy importante de usuarios. 

  
Desventajas de utilizar Sass 

Como todo, Sass tiene algunas desventajas, que son extensibles a cualquier otro preprocesador que se utilice: 

Hay que aprender a utilizar una nueva herramienta, lo que para algunos supone una desventaja. 

  
Hay un tiempo de consumo en el proceso de generación o compilación del CSS, 
sobre todo si es el archivo SCSS es muy grande. No es mucho tiempo, pero sí que existe esa pequeña demora. 

Tiene una sintaxis más compleja que CSS. 

Ejemplo de uso de Sass 

A continuación, veremos un pequeño ejemplo de Sass, dónde podemos ver los elementos básicos de este preprocesador CSS,  

como estructuras repetitivas, variables, funciones o parámetros: 

.row { 

        @include flex_mixin: 

} 

    /// Número de elementos máximos que voy a tener a lo ancho del layout 

    /// @group layout 

    $num_elementos: 8; 

    ///Función que devuelve la anchura correspondiente al elemento 

    @function anchura_col($i) { 

        @return (100 / $num_elementos)*$i ; 

        } 

    ///Bucle para generar las clases para tamaños medios 

    @for $i from 1 through $num_elementos { 

        .row > .col#{$i} { 

            width: #{anchura_col($i)} + “%”; 

        } 

    } 

Podemos ver que hay muchos elementos, pero tienen una sintaxis muy similar a CSS, añadiendo potencialidades de lenguaje de programación.  

Una vez que ejecutamos nuestro fichero SCSS, se generaría un fichero CSS de salida de forma automática. 

 --------------------------------------------------------------------------------------------------------------------------------------------------

Que es  scss? 

scss es un fichero con extencion css, pero tiene las cualidades de sass, la sintaxis es muy parecida al de css, la de sass es mas compleja,  

a scss se le puede agregar funciones variables entre otros 

SASS es el pre-procesador y la sintaxis al completo, mientras que SCSS es la sintaxis de CSS pero con todas las ventajas de SASS. 
Ahora que ya está clara la diferencia entre SASS y SCSS vamos a ver todas las características que hace que SASS sea mucho más potente que CSS 

--------------------------------------------------------------------------------------------------------------------------------------------------
 
¿Qué es y para qué sirve Webpack? 

Webpack es un module bundler , es decir, un empaquetador de módulos. hablamos que muchos archivos vienen a ser unos pocos, 
al final. Generalmente estos archivos van a representar módulos, cuando de Javascript se trata. 
Cada módulo representa un conjunto de código que cumple con un objetivo determinado. 

 

Módulos dependen de otros, y esta gestión de dependencias es posible gracias a algún module system de Javascript 
(es decir, una especificación sobre cómo importar y exportar estos módulos). 

Webpack permite optimizar todo este proceso: 

Gestión de dependencias entre módulos 

Minificar, comprimir y unir nuestro código 

Solicitar archivos según se requiera 

--------------------------------------------------------------------------------------------------------------------------------------------------

MODELO DE CAJA: El modelo de caja CSS es un módulo CSS que define cajas rectangulares, 
incluyendo sus rellenos y márgenes, que son generadas para los elementos y que se disponen de acuerdo al modelo de formato visual.

Referencia
Propiedades
Propiedades que controlan el flujo del contenido en una caja.

    box-decoration-break (en-US)
    box-sizing
    overflow
    overflow-x (en-US)
    overflow-y

Propiedades que controlan el tamaño de una caja.

    height
    width
    max-height
    max-width (en-US)
    min-height
    min-width

Propiedades que controlan los márgenes de una caja.

    margin
    margin-bottom
    margin-left (en-US)
    margin-right
    margin-top (en-US)

Propiedades que controlan los rellenos de una caja

    padding
    padding-bottom
    padding-left (en-US)
    padding-right (en-US)
    padding-top

Otras propiedades

    box-shadow
    visibility

--------------------------------------------------------------------------------------------------------------------------------------------------
¿Qué es el Responsive Design?

El Responsive Design o diseño adaptativo es la técnica que se usa en la actualidad para tener una misma web adaptada a las diferentes plataformas
 que nos brinda la tecnología: ordenador, tablet, Smartphone, iPad, Kindle y, en resumen, todas las resoluciones de pantalla existentes. 

 CSS media queries

Las media queries (en español "consultas de medios") son útiles cuando deseas modificar tu página web o aplicación en 
función del tipo de dispositivo (como una impresora o una pantalla) o de características y parámetros específicos 
(como la resolución de la pantalla o el ancho del viewport del navegador).

Se utilizan para:

    Aplicar estilos condicionales con las reglas-at @media e @import de CSS.
    Indicar medios específicos en los elementos <link>, <source> y otros elementos HTML.
    Testear y monitorizar los estados de los medios usando los métodos de javascript Window.matchMedia() y MediaQueryList.addListener().

Sintaxis

Las media queries consisten de un tipo de medio opcional y una o más expresiones de características de medios. 
Varias consultas se pueden combinar utilizando operadores lógicos. No distinguen entre mayúsculas y minúsculas.

El resultado de la consulta es "verdadero" cuando el tipo de medio (si se especifica) coincide con el 
dispositivo en el que se está mostrando el documento y todas las expresiones en el media query son "verdaderas". En este caso, 
se aplica los estilos correspondientes, siguiendo las reglas usuales de cascada.

Las consultas sobre tipos de medios desconocidos son siempre falsas.

<!-- CSS media query on a link element -->
<link rel="stylesheet" media="(max-width: 800px)" href="example.css" />

<!-- CSS media query within a style sheet -->
<style>
@media (max-width: 600px) {
  .facet_sidebar {
    display: none;
  }
}
</style>

Media Types

Los Media Types (tipos de medios) describen la categoría general de un dispositivo. Excepto cuando se utilizan los operadores lógicos not o only, 
el tipo de medio es opcional y será interpretada como all.

all

    Apto para todos los dispositivos.
print

    Destinado a material impreso y visualización de documentos en una pantalla en el modo de vista previa de impresión.
screen

    Destinado principalmente a las pantallas.
speech

    Destinado a sintetizadores de voz.


Tamaños de pantalla comunes

    Móvil: 360 x 640
    Móvil: 375 x 667
    Móvil: 360 x 720
    iPhone X: 375 x 812
    Pixel 2: 411 x 731
    Tableta: 768 x 1024
    Un ordenador portátil: 1366 x 768
    Un ordenador portátil o desktop de alta resolución: 1920 x 1080

--------------------------------------------------------------------------------------------------------------------------------------------------
¿Por que usar rem en vez de px?

A diferencia de PX, las unidades relativas como %, EM y REM se adaptan mejor al diseño responsivo y también ayudan a cumplir 
con los estándares de accesibilidad. Las unidades relativas escalan mejor en diferentes dispositivos porque pueden escalar 
hacia arriba y hacia abajo según el tamaño de otro elemento.

¿Cuándo debería usar una unidad sobre otra?

En última instancia, no existe una respuesta perfecta para esta pregunta. En general, 
a menudo es mejor elegir una de las unidades relativas en lugar de PX para que tu página web tenga la mejor 
oportunidad de representar un diseño responsivo. Sin embargo, elije PX si necesitas asegurarte de que un elemento nunca 
cambie de tamaño en ningún punto de interrupción y permanezca igual independientemente de si un usuario 
ha elegido un tamaño predeterminado diferente. Las unidades PX garantizan resultados consistentes incluso si eso no es ideal.

--------------------------------------------------------------------------------------------------------------------------------------------------

¿Qué es una Petición HTTP (y Cómo Funciona)?

Piensa en una petición HTTP como si tu navegador se conectara al servidor y le pidiera un recurso específico o le enviara datos. 
Hay varios tipos de métodos de petición HTTP, que modifican completamente el tipo de respuesta que obtienes del servidor. Los más comunes son:

    GET. Es el método de petición HTTP más utilizado con diferencia. Una petición GET solicita al servidor una información o recurso concreto. 
    Cuando te conectas a un sitio web, tu navegador suele enviar varias peticiones GET para recibir los datos que necesita para cargar la página.

    HEAD. Con una petición HEAD, sólo recibes la información de la cabecera de la página que quieres cargar. 
    Puedes utilizar este tipo de petición HTTP para conocer el tamaño de un documento antes de descargarlo mediante GET.

    POST. Tu navegador utiliza el método de petición HTTP POST cuando necesita enviar datos al servidor. Por ejemplo, 
    si rellenas un formulario de contacto en un sitio web y lo envías, estás utilizando una petición POST para que el servidor 
    reciba esa información.

    PUT. Las peticiones PUT tienen una funcionalidad similar a la del método POST. Sin embargo, en lugar de enviar datos, 
    utilizas las peticiones PUT para actualizar información que ya existe en el servidor final.


¿Qué es una API?

Las API son mecanismos que permiten a dos componentes de software comunicarse entre sí mediante un conjunto de definiciones y protocolos. 
Por ejemplo, el sistema de software del instituto de meteorología contiene datos meteorológicos diarios. 
La aplicación meteorológica de su teléfono “habla” con este sistema a través de las API y le muestra las actualizaciones 
meteorológicas diarias en su teléfono.

¿peticion API  con fetch?

fetch('https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API key}')
.then(res => console.log(res))

pero sale error.
--------------------------------------------------------------------------------------------------------------------------------------------------
¿Qué es el DOM?

El modelo de objeto de documento (DOM) es una interfaz de programación para los documentos HTML y XML. 
Facilita una representación estructurada del documento y define de qué manera los programas pueden acceder, al fin de modificar, 
tanto su estructura, estilo y contenido. El DOM da una representación del documento como un grupo de nodos y objetos estructurados 
que tienen propiedades y métodos. Esencialmente, conecta las páginas web a scripts o lenguajes de programación.

document y window son objetos cuya interfaces son generalmente muy usadas en la programación de DOM. 
En término simple, el objeto window representa algo como podría ser el navegador, y el objeto document es la raíz del documento en sí. 
Element hereda de la interfaz genérica Node, y juntos, estas dos interfaces proporcionan muchos métodos y propiedades utilizables 
sobre los elementos individuales. Éstos elementos pueden igualmente tener interfaces específicas según el tipo de datos representados, 
como en el ejemplo anterior del objeto table. Lo siguiente es una breve lista de los APIS comunes en la web y en las páginas escritas 
en XML utilizando el DOM.

    document.getElementById(id)
    element.getElementsByTagName(name)
    document.createElement(name)
    parentNode.appendChild(node)
    element.innerHTML
    element.style.left
    element.setAttribute
    element.element.getAttribute
    element.addEventListener
    window.content
    window.onload
    window.dump
    window.scrollTo

    

    - document.getElementById

    Nos permite obtener un elemento del DOM a través de su ID. Retorna un único nodo del HTML, porque solo en una página cada id debe ser único, 
    es decir, no puede haber mas de un elemento con el mismo ID. Un ejemplo seria obtener el elemento con el id firstName, 
    lo hacemos de la siguiente manera:

    document.getElementById("firstName");


    - document.getElementsByTagName

    Nos permite obtener una lista (NodeList) con todos los nodos que tienen definida la etiqueta proporcionada.  
    Es un método que puede traer 0, 1 o n Nodos. Un ejemplo seria obtener de nuestro documento todos los elemento que sean un span, 
    lo hacemos de la siguiente manera:

    document.getElementsByTagName("span");



    - document.getElementByClassName

    Funciona similar al anterior, pues nos retorna una lista, pero en este caso nos devuelve los nodos que entre sus clases contenga 
    la especificada en el argumento del método, es decir, vamos a identificar una clase y traemos todos los elementos que contengan dicha clase, 
    supongamos que queremos obtener todos los nodos que contengan la clase container, lo haríamos de la siguiente manera:

    document.getElementsByClassName("container");



    - document.querySelector

    Nos permite obtener cualquier elemento del DOM de acuerdo al argumento que le indiquemos, podemos pasarle una cadena de caracteres 
    que contiene uno o mas selectores CSS, estos deben ir separado por comas. Este método retorna el primer elemento que coincida con el filtro, 
    es decir, si existen varios elementos que coincidan con la búsqueda este nos retornara el primero que encuentre. 
    Si no encuentra ningún elemento retorna null. Veamos un ejemplo donde buscaremos un elemento que contenga la clase container.

    document.querySelector(".container");

    Como vemos debemos especificar el símbolo del selector, similar como ocurre en CSS, si queremos obtener por clase (".container"), 
    ID (#container), etiqueta directamente (“h1”).



    - document.querySelectorAll

    Este método es casi igual al anterior a diferencia de que este devuelve una lista (NodeList) donde se encuentran 
    todos los elementos que coincidan con el o los selectores indicados. Supongamos que queremos hacer la misma búsqueda del 
    ejemplo del ítem anterior, obtener los elementos con la clase container

    document.querySelectorAll(".container");

    A diferencia del método anterior que nos devuelve la primera coincidencia, aquí vamos a obtener todos esos elementos que 
    coincidan con el selector indicado.

    -----------------------------------------------------------------------------------------------------------------------------------

    ****************************************Solcion actividad del 26 de enero************************************************

    1) esto lo realizamos con innerHTML, de esta forma llamamos los datos de html a js para que interactuen con la API que llamamos con el metodo fetch o segun el metodo utilizado
--------------------------------------------------------------------------------------------------------------------------------------------    
    2) ¿Qué son las variables de entorno?

Las variables de entorno son variables externas a nuestra aplicación que residen en el sistema operativo o en el contenedor de la aplicación que se está ejecutando. Una variable de entorno es simplemente un nombre asignado a un valor.

Por convención, el nombre se escribe con mayúscula y los valores son cadenas de texto, por ejemplo: PORT=8080.

Normalmente, nuestras aplicaciones requieren que se establezcan muchas variables de entorno para que funcionen. Al confiar en configuraciones externas, su aplicación se puede implementar fácilmente en diferentes entornos. Estos cambios son independientes de los cambios en el código, por lo que no requieren que su aplicación sea reconstruida.

Los datos que cambian según el entorno en el que se ejecuta su aplicación deben configurarse como variables de entorno. Algunos ejemplos comunes son:

Dirección y Puerto HTTP.
Credenciales de Base de Datos.
Ubicación de archivos y carpetas estáticos.
Credenciales de API's externas.

Utilizar archivos .env para guardar la variable de entorno con la api key

.env son sin duda la forma más fácil y popular de gestionar las variables de entorno. La idea es sencilla: almacenas tus variables de entorno en un archivo llamado .env en la raíz de tu proyecto. La aplicación busca las variables en este archivo y las carga para utilizarlas durante el tiempo de ejecución. Este es el aspecto de un archivo típico de .env:

ejemplo:
VAR_UNO=SOME_KEY_HERE
VAR_DOS=SOME_OTHER_KEY_HERE
---------------------------------------------------------------------------------------------------------------------------------------------------
3) Que es GITIGNORE?

El archivo .gitignore es un archivo de texto que le dice a Git qué otros archivos y carpetas de un proyecto debe ignorar.

Un archivo .gitignore local se coloca normalmente en el directorio de origen de un proyecto. También puedes crear un archivo .gitignore global y cualquier entrada que contenga será ignorada en todos tus repositorios Git por igual.

Para crear un archivo .gitignore local, crea un archivo de texto y llámalo .gitignore (recuerda incluir el . al principio). Después edita el archivo como sea necesario. Cada línea nueva debería contener el archivo o carpeta que quieres que Git ignore.

Las entradas en este archivo también pueden seguir un modelo similar.

* se usa para encontrar coincidencias
/ se usa para ignorar nombres de ruta relacionados con el archivo .gitignore
# se usa para añadir comentarios al archivo .gitignore
Este es un ejemplo de cómo se vería un archivo .gitignore:

# Ignorar archivos del sistema de Mac
.DS_store

# Ignorar carpeta node_modules
node_modules

# Ignorar todos los archivos de texto
*.txt

# Ignorar archivos relacionados con claves de una API
.env

# Ignorar archivos de configuración SASS
.sass-cache
Para añadir o cambiar tu archivo .gitignore global, ejecuta el siguiente comando:

git config --global core.excludesfile ~/.gitignore_global
Esto creará el archivo  ~/.gitignore_global. Ahora puedes editar ese archivo de la misma manera que un archivo .gitignore local. Todos tus repositorios Git ignorarán los archivos y carpetas que aparecen enumerados en el archivo .gitignore global.

---------------------------------------------------------------------------------------------------------------------------------------------------

4) asincronismo

Resulta que JavaScript es un lenguaje de programación asincrono. Lo que quiere decir esto es que al ejecutar código JavaScript el hilo de ejecución continuará a pesar de encontrarse en situaciones en las que no obtenga un resultado inmediatamente. Por ejemplo, cuando hacemos el pedido de información a un servidor, la respuesta posiblemente demore un poco. Sin embargo, el hilo de ejecución de JavaScript continuará con las demás tareas que hay en el código.

2. Callbacks
Un callback es simplemente una función que se pasa como parametro a otra funcion. Nosotros podemos construir funciones que usen callbacks de la siguiente manera.

function saludar(saludo){
    saludo();
}

saludar(function(nombre) {
    console.log(`Hola ${nombre}`)
})
Una función en JavaScript que tiene un callback es el setTimeout(). Esta función ejecuta el callback despúes de esperar cierto tiempo el cual también le pasamos como parámetro.

// setTimeout(funcion, tiempo_ms);
setTimeout(function(){
    console.log('Hola')
}, 2000);
Esta función ejecuta el callback solo despúes de que hayan pasado 2000 milisegundos.

Con ayuda de esta función podemos crear un código que nos permita visualizar la asincronia de JavaScript.

// Usando función anonima
console.log('A')
setTimeout(function () {
    console.log('B')
}, 2000)
console.log('C')
/* Resultado del código anterior
 A
 C
 B  Despues de 2 segundo*/
La asincronia de JavaScript nos permite visualizar en consola la letra C mucho antes de la B, el cual demora 2 segundos. Como puedes ver la ejecución no se detiene dos segundos, esta continua y luego de dos segundos aparece C.

Para tener un cierto control en el código asincrono de JavaScript existen las promesas, las cuales estudiaremos a continuación.

3. Promesas
Las promesas llegan a JavaScript en la versión 6 de EcmaScript. Una promesa es el objeto que representa un valor que estará disponeble ahora, en el futuro o quiza nunca. Entonces como no sabemos cuando estarán disponibles. Por esta razón dejamos preparado dentro de la promesa el código que se ejecutará cuando el resultado llegue o incluso cuando el resultado es un error.

Podemos crear una promesa de la siguiente manera.

let  x = 11
const p = new Promise((resolve, reject) =>{
    if(x == 10){
        resolve('La variable es igual a 10');
    }else{
        reject('La variable no es igual a 10');
    }
});
En la función flecha del código anterior tenemos dos parametros, el primer parámetro resolve es una función que recibe como parametro el objeto que queremos que devuelva cuando el código tuvo el resultado que esperamos. Mientras que reject es una función que toma como parametro el objeto que devolverá si obtenemos un error, en nuestro código asincronico.

En resumen usando una promesa podemos recibir el resultado que necesita de una espera y ejecutar código luego de que el resultado llegue. Entonces probemos las promesas con el setTimeout.

let mensaje = new Promise((resolve, reject)=>{
    setTimeout(function () {
        resolve('Este es el mensaje');
    }, 2000);
})
De esta forma creamos un objeto promesa con el mensaje como resultado resolve favorable de la promesa que devolverá luego de 2 segundos. Ahora para controlar la promesa usamos el método then y catch que vienen junto con las promesas.

mensaje.then(m =>{
    console.log(m)  
}).catch(function () {
    console.log('error');
})
Entonces para capturar el resultado favorable de la promesa usamos then(). En nuestro caso se trata del mensaje que lo mostraremos usando un console.log(). Por otra parte el catch captura el resultado fallido o reject de la promesa. En nuestro caso no implementamos ninguno asi que nuestra función anonima dentro del catch no recibe ningun parametro y solo muestra el mensaje de error.

Listo ya sabemos que una promesa es como un tipo de dato y es por este motivo que muchas funciones de JavaScript y/o de librerias externas cuyo resultado es asincrono osea que demorará un tiempo en llegar están inplementados en promesas. Uno de estos métodos es fetch.

4. El método Fetch
Este método nos permite hacer una petición a un API y es justamente un callback. Por lo que tenemos que recibirlo usando then y catch de la siguiente forma.

let pokemones = fetch("https://pokeapi.co/api/v2/pokemon/1");

pokemones.then(res => res.json())
    .then(data => {
        console.log(data.name);
    }).catch(error => console.log(error))
Esta es la forma que comunmente se utiliza a fetch pero hay que acomodarlo de tal manera que sea un poco más entendible.

let pokemones = fetch("https://pokeapi.co/api/v2/pokemon/1");

pokemones
    .then(res => {
        return res.json()
    })
    .then(data => {
        console.log(data.name);
    }).catch(error => console.log(error))
Como puedes ver en el código anterior se pueden encadenar métodos then, pero se pueden hacer solo cuando el return del then anterior es una promesa. En este caso si nosotros vemos la implementación de json() veremos que este método devuelve una promesa. Por lo que el segundo then es la captura del resolve del json(). Asi que si intentamos descomponer más al código anterior tendríamos algo asi.

// primera promesa
let pokemones = fetch("https://pokeapi.co/api/v2/pokemon/1");

// segunda promesa
let respuesta = pokemones.then(res => {return res.json()});

respuesta.then(data => {
    console.log(data.name);
})
Entonces si nosotros quisieramos ejecutar el fetch de manera ordenada y sincrona para ver los cinco primeros pokemones podemos hacer lo siguiente.

function obtener_pokemon(id){
    let url = "https://pokeapi.co/api/v2/pokemon/" + id;
    return fetch(url).then(res => {return res.json()});
}


obtener_pokemon(1).then(data => {
    console.log(data.name);
    return obtener_pokemon(2);
}).then(data =>{
    console.log(data.name);
    return obtener_pokemon(3);
}).then(data =>{
    console.log(data.name);
    return obtener_pokemon(4);
}).then(data =>{
    console.log(data.name);
    return obtener_pokemon(5);
}).then(data =>{
    console.log(data.name);
})
5. Async Await
Ahora veremos una de las mejores caracteristicas que salieron en la especificación 8 de EcmaScript. El popular async await. Usamos el async para definir una función donde se encontrará el await que nos permitirá esperar una promesa de tal forma que podamos volver nuestro código sincrono.

function obtener_pokemon(id){
    let url = "https://pokeapi.co/api/v2/pokemon/" + id;
    return fetch(url).then(res => {return res.json()});
}

async function nombrar_pokemones() {
    let pokemon1 = await obtener_pokemon(1);
    console.log(pokemon1.name);
}
Usando el async await podemos lograr esto, que la variable espere por su resultado antes de ejecutar el console.log(). Y como podemos hacer que una variable espere podemos lograr incluso esto.

async function nombrar_pokemones() {
    for (let i = 1; i < 6; i++) {
        let pokemon = await obtener_pokemon(i);
        console.log(pokemon.name);
    }
}
Como ves, el async await nos permite esperar el resolve de una promesa de tal manera que podamos obtener un resultado sincrono.

O incluso podemos hacerlo usando forEach de la siguiente manera.

function obtener_pokemones(){
    let url = "https://pokeapi.co/api/v2/pokemon/";
    return fetch(url).then(res => {return res.json()});
}

async function nombrar_pokemones() {
    let pokemones = await obtener_pokemones();
    pokemones.results.forEach(pokemon => {
        console.log(pokemon.name)
    })
}
En este caso lo que pedimos al api es una lista con los 20 primeros pokemones pero estos están como una lista de objetos dentro del objeto result en la respuesta json que obtendremos. Asi que usamos el forEach para recorrer cada elemento del objeto results. Sin embargo, muchas veces lo que buscaremos será llevar una lista de objetos directamente a un arreglo para eso existe el método map. El cual lo podemos utilizar de la siguiente forma.

async function nombrar_pokemones() {
    let pokemones = await obtener_pokemones();
    let arregloPokemones = pokemones.results.map(pokemon => pokemon.name)
    console.log(arregloPokemones)
}
El método map recibe una función flecha donde a partir del parametro que recibe que es cada elemento del results retorna lo que queremos que esté dentro del arreglo.

La forma de capturar un error cuando usamos Async Await es haciendo uso de try-catch como en el siguiente ejemplo.

try {
    const data = await fetch('https://pokeapi.co/api/v2/pokemon/' + name); 
} catch (error) {
    console.log(error);
}

---------------------------------------------------------------------------------------------------------------------------------------------------

5) callback hell

JavaScript es un lenguaje de programación muy poderoso que se distingue de los demás de muchos modos. No solamente se distingue porque es un lenguaje que nos permite programar tanto para el frontend como para el backend de la web, sino también porque se basa en eventos en vez de en cadenas.

Esta base le permite a JavaScript crear asincronía, un concepto que se refiere a la habilidad de programar acciones que pueden ser ejecutadas en tiempos no inmediatos. Para ello, se utilizan promesas, condicionales y métodos de tiempo. es un fenómeno que surge de la asincronía de este lenguaje de programación.

¿Qué es el callback hell en JavaScript?
Antes de explicarte qué es el callback hell en JavaScript, te sugerimos leer nuestros posts sobre qué son las promesas en JavaScript y cómo anidar métodos en JavaScript. Estos dos te darán el contexto necesario para entender mejor este fenómeno.

Nota: estudiar las promesas, como anidar metodos

Supongamos que queremos hacer una llamada al servidor API. Para ello, se crea una promesa (promise 1) con una gestión de respuesta (response). Ahora, pensemos que queremos ejecutar una acción asincrónica distinta que depende de esta respuesta. Entonces, crearemos otra promesa (promise 2) anidada a la primera. Esta promesa, a su vez, debe gestionarse con un método then. Aquí hemos empezado un árbol de promesas que puede detenerse o continuar.

Este ciclo de promesas puede continuar cada vez que queramos ejecutar una acción dependiente del resultado anterior y gestionarla. Este árbol de promesas se vería similar a las líneas de código que te mostramos a continuación, cada una ejecutando una acción individual, pero que impacta en las demás:

// llamar al servidor

p1.then (response => {

// enviar los datos a la db

p2.then (response2 {

// recoger el resultado de la db y escribirlo en un log

p3.then (response3 => {

// cuando el log pasa de 3MB, subirlo a un s3

p4.then (response4 => {

p5.then (response5 => {

}

En las líneas de código anteriores, hemos hecho que los comportamientos que queremos ir gestionando se aniden, creando una dependencia de referencias eterna. A esta anidación de acciones la llamamos callback hell en JavaScript. Esta situación es tan conocida en el mundo de la programación que tiene su propia página web. Además, el proceso que nos lleva a ella se conoce como highway to callback hell. Por ello, te invitamos a leer la página callbackhell.com para conocer más sobre este fenómeno.

La anidación de acciones a ejecutar o callback hell también puede suceder cuando usamos los condicionales if …else, que nos ayudan a plantear situaciones en las que una acción sucede si algo pasa y otra si esto no pasa. Para conocer más sobre este condicional, te invitamos a leer nuestro post sobre cómo usar if else else en JavaScript. Esta situación es relativamente fácil de romper cuando utilizamos if, pero no es el caso de las promesas.

¿Qué hacer con el callback hell en JavaScript?
Ahora que sabes qué es el callback hell en JavaScript, seguro que estás pensando en cómo evitar esta situación. La realidad es que hay muchos momentos en los que deberás anidar promesas o condicionales, porque solo así crearás cadenas de acciones asíncronas. Por ello, debes pensar en cómo resolver el callback hell, no en cómo evitarlo. Una de las maneras más populares de hacerlo es a través de los métodos async y await.

--------------------------------------------------------------------------------------------------------------------------------------------------

6)  Que es hoinsting?

El concepto de Hoisting fue pensado como una manera general de referirse a cómo funcionan los contextos de ejecución en JavaScript (específicamente las fases de creación y ejecución). Sin embargo, el concepto puede ser un poco confuso al principio.

Conceptualmente, por ejemplo, una estricta definición de hoisting sugiere que las declaraciones de variables y funciones son físicamente movidas al comienzo del código, pero esto no es lo que ocurre en realidad. Lo que sucede es que las declaraciones de variables y funciones son asignadas en memoria durante la fase de compilación, pero quedan exactamente en dónde las has escrito en el código.

Una de las ventajas en JavaScript de colocar (ponerlas en memoria) las declaraciones de funciones antes de ejecutar cualquier otro segmento de código es que permite utilizar una función antes de declararla en el código. Por ejemplo:

function nombreDelGato(nombre) {
  console.log("El nombre de mi gato es " + nombre);
}

nombreDelGato("Maurizzio");
/*
El resultado del código es: "El nombre de mi gato es Maurizzio"
*/

El código escrito arriba está escrito de la manera que sería esperada para que funcione. Ahora, veamos qué sucede cuando llamamos a la función antes de escribirla:

nombreDelGato("Dumas");

function nombreDelGato(nombre) {
  console.log("El nombre de mi gato es " + nombre);
}
/*
El resultado del código es: "El nombre de mi gato es Dumas"
*/

Como se puede observar, aunque primero llamamos a la función en el código, antes de que sea escrita, el código aún funciona. Esto sucede por la manera en la que el contexto de ejecución trabaja en JavaScript.

-----------------------------------------------------------------------------------------------------------------------------------------------


- ?Evente bubbling:

Para entender el concepto de bubbling, hay que hablar antes de los eventos

Los eventos son la manera que tenemos de monitorizar el comportamiento de nuestros usuarios, por ejemplo al detectar cuando se hace click en un botón

Para capturar esos eventos se utilizan los listeners, con la siguiente estructura

el.addEventListener(event, () => {})
Donde en este caso el event será del tipo click

const el = document.getElementById('mi_boton')
el.addEventListener('click', () => {
  console.log('elemento clicado!')
})
Dicho esto, el bubbling y el capturing ocurre cuando esos eventos se propagan, por ejemplo aquí que tienes un botón dentro de otro botón y dentro de un div:

<div id="mi_div">
  <button id="mi_boton_1">
    Boton 1
    <button id="mi_boton_2">Boton 2</button>
  </button>
</div>
document.getElementById('mi_boton_1').addEventListener('click', () => console.log('boton 1 clicado!'))
document.getElementById('mi_boton_2').addEventListener('click', () => console.log('boton 2 clicado!'))
document.getElementById('mi_div').addEventListener('click', () => console.log('div clicado!'))
Si aprietas el botón 2, tendrás un evento del botón 2, luego uno del botón 1, y luego otro del div, y esto es el bubbling

En realidad no porque los botones no pueden estar anidados, pero se entiende el concepto

Lo contrario del bubbling es el capturing, es decir, es lo mismo pero el evento va en la dirección opuesta, nace en el elemento más general y se va propagando hasta llegar al elemento original

Eso solo ocurre si lo especificamos en el listener

document.getElementById('mi_boton_1').addEventListener('click', () => console.log('boton1 clicado!'), { capture: true })
document.getElementById('mi_boton_2').addEventListener('click', () => console.log('boton2 clicado!'), { capture: true })
document.getElementById('mi_div').addEventListener('click', () => console.log('div clicado!'), { capture: true })
Pero quién quiere esto? Ni idea, lo habitual es evitar el bubbling de la siguiente manera:

document.getElementById('mi_boton_1').addEventListener('click', e => {
  e.stopPropagation()
  console.log('boton 1 clicado!')
})
document.getElementById('mi_boton_2').addEventListener('click', e => {
  e.stopPropagation()
  console.log('boton 2 clicado!')
})
document.getElementById('mi_div').addEventListener('click', e => {
  e.stopPropagation()
  console.log('div clicado!')
})
Y si te preguntas cómo hacer esto en React, pues sería así

import React, { useRef } from 'react'

const log = (e, msg) => {
  e.stopPropagation()
  console.log(msg)
}

export const App = () => {
  const div = useRef()
  const button = useRef()

  return (
    <div ref={div} onClick={e => log(e, 'yo también!')}>
      <h1>Hola</h1>
      <button ref={button} onClick={e => log(e, 'clicando!')}>
        clica!
      </button>
    </div>
  )
}

export default App

-scope?:

El scope puede definirse como el alcance que una variable tendrá en tu código. En otras palabras, el scope decide a qué variables tienes acceso en cada parte del código. Existen dos tipos de scope, el scope global y el scope local. 

Qué es el Scope Local

Cuando puedes acceder a una variable únicamente en cierta parte del código, se dice que esa variable está declarada en el scope local. Estas también son conocidas como variables locales. Un ejemplo de esto es cuando una variable está declarada dentro de un bloque o una función. Si tratas de acceder a esta variable fuera de esta función o bloque, tendrás un error que dirá que la variable no está definida.

unction platzi() {
	const soyEstudiante = true;
	console.log(soyEstudiante);
}

platzi(); // true
console.log(soyEstudiante); // soyEstudiante is not defined

Qué es el Scope Global

Se dice que una variable está en el sope global cuando está declarada fuera de una función o de un bloque. También son conocidas como variables globales. Puedes acceder a este tipo de variables desde cualquier parte de tu código, ya sea dentro o fuera de una función.

const soyEstudiante = true;

function platzi() {
	console.log(soyEstudiante);
}

platzi(); //true
console.log(soyEstudiante); //true
A pesar de que JavaScript nos permite declarar una variable como global, no es una buena práctica. Una de las razones es porque tenemos la posibilidad de declarar dos variables globales en distintas partes del código con el mismo nombre sin notarlo.

-----------------------------------------------------------------------------------------------------------------------------------------------

-prototype?:

Los prototipos son un mecanismo mediante el cual los objetos en JavaScript heredan características entre sí

JavaScript es un lenguaje basado en prototipos, por lo tanto entender el objeto prototype es uno de los conceptos más importantes que los profesionales de JavaScript necesitan saber. 

Objeto prototype
En honor a la claridad, vamos a examinar el siguiente ejemplo:

function Punto2D(x, y) {
  this.x = x;
  this.y = y;
}
Al declararse la función Punto2D, una propiedad predeterminada llamada  prototype será creada para ella (ten en cuenta que, en JavaScript, una función es también un objeto). La propiedad prototype es un objeto que contiene una propiedad constructor y su valor es la función Punto2D: Punto2D.prototype.constructor = Punto2D. Y cuando tú llamas a Punto2D con la palabra reservada new, los objetos recién creados heredarán todas las propiedades de Punto2D.prototype. Para verificar esto, puedes agregar un método llamado mover en  Punto2D.prototype de la siguiente manera:

Punto2D.prototype.mover  = function(dx, dy) {
  this.x += dx;
  this.y += dy;
}

var p1 = new Point2D(1, 2);
p1.mover (3, 4);
console.log(p1.x); // 4
console.log(p1.y); // 6
El Point2D.prototype es llamado objeto prototipo o prototipo del objeto p1 y de cualquier otro objeto creado con la sintaxis new Point2D(...) . Puedes agregar tantas propiedades al objeto Point2D.prototype como quieras. Lo que suele hacerse es declarar métodos en Point2D.prototype y otras propiedades se declararán en la función constructora.

Los objetos integrados en JavaScript se construyen de manera similar. Por ejemplo:

El prototipo de los objetos creados con la sintaxis new Object() o {} es Object.prototype
El prototipo de los arreglos creados con la sintaxis new Array() o [] es Array.prototype
Y es igual con otros objetos integrados como Date y RegExp.
Object.prototype es heredado por todos los objetos y no tiene prototipo (su prototipo es null)

Cadena de prototipos

El mecanismo de la cadena del prototipo es simple: cuando accede a una propiedad p en el objeto obj, el motor de JavaScript buscará esta propiedad dentro del objeto obj. Si el motor falla en la búsqueda, continúa buscando en el prototipo de objeto obj y así sucesivamente hasta llegar a Object.prototype. Si finalizada la búsqueda no se ha encontrado nada, el resultado será undefined. Por ejemplo:

var obj1 = {
  a: 1,
  b: 2
};

var obj2 = Object.create(obj1);
obj2.a = 2;

console.log(obj2.a); // 2
console.log(obj2.b); // 2
console.log(obj2.c); // undefined
En el fragmento de código anterior, la declaración var obj2 = Object.create(obj1) creará el objeto obj2 con el objeto prototipo obj1. En otras palabras, obj1  se convierte en el prototipo de obj2 en lugar de Object.prototype por defecto. Como puedes ver,  bno es una propiedad de obj2, pero puedes acceder a ella a través de la cadena de prototipos. Sin embargo, para la propiedad c,  se obtiene un valor undefined porque no se puede encontrar en obj1 y en Object.prototype.

Clases

En ES2016, ahora podemos usar la palabra clave Class , así como los métodos mencionados anteriormente para manipular el prototype. Las clases de JavaScript son atractivas para los desarrolladores con experiencia en programación orientada a objetos, pero esencialmente hace lo mismo que el anterior.

class Rectangle {
  constructor(height, width) {
    this.height = height
    this.width = width
  }

  get area() {
    return this.calcArea()
  }

  calcArea() {
    return this.height * this.width
  }
}

const square = new Rectangle(10, 10)

console.log(square.area) // 100
Esto es básicamente lo mismo que:

function Rectangle(height, width) {
  this.height = height
  this.width = width
}

Rectangle.prototype.calcArea = function calcArea() {
  return this.height * this.width
}
Los métodos getter y setter en las clases vinculan una propiedad Object a una función que será llamada cuando se busque esa propiedad. Esto es solo azúcar sintáctico para ayudar a que sea más fácil buscar o establecer propiedades.

-----------------------------------------------------------------------------------------------------------------------------------------------
-use strict?:

La "use strict"directiva era nueva en ECMAScript versión 5.

No es una declaración, sino una expresión literal, ignorada por versiones anteriores de JavaScript.

El propósito de "use strict"es indicar que el código debe ejecutarse en "modo estricto".

Con el modo estricto, no puede, por ejemplo, usar variables no declaradas.

Declaración de modo estricto

El modo estricto se declara agregando "uso estricto"; al comienzo de un script o una función.

Declarado al comienzo de una secuencia de comandos, tiene un alcance global (todo el código de la secuencia de comandos se ejecutará en modo estricto):

Ejemplo
"use strict";
x = 3.14;       // This will cause an error because x is not declared



